  defaults:
    icon: "mdi:lightning-bolt"
    target: "Kessel"
    interval: "5"
    unit_numerator: "kWh"
    unit_minor: "Wh"
    property_minor: $property_minor
    property_numerator: $property_numerator
    state_class: "total_increasing"
    device_class: "energy"

  globals:
  # Used to store the offset
    - id: gOFFSET_${property_minor}
      type: float
      restore_value: yes
      initial_value: "0.0"

  sensor: 
  # Create sensor for minor entity
    - platform: template
      name: ${property_minor}
      id: ${property_minor}
      unit_of_measurement: ${property_minor}
      icon: ${icon}
      state_class: $state_class
      device_class: ${device_class}
      internal: true
      accuracy_decimals: 3
      filters:
        - multiply: 0.001
        - lambda: return x - id(gOFFSET_${property_minor});
        - clamp:
            min_value: 0

    # Create sensor for numerator entity
    - platform: template
      name: $property_numerator
      id: $property_numerator
      unit_of_measurement: ${unit_numerator}
      icon: ${icon}
      state_class: $state_class
      device_class: ${device_class}
      internal: false
      accuracy_decimals: 3

  esphome:
    on_boot:
      priority: -100
      then:
        - lambda: |-
            // Handle the values received from the heat pump. Wh value is just stored in an internal sensor and published together with the kWh value on reception.
            CallbackHandler::instance().addCallback(std::make_pair(${target},Property::k${property_minor}),[](const SimpleVariant& value){
              id(${property_minor}).publish_state(static_cast<std::uint16_t>(value));
            });
            CallbackHandler::instance().addCallback(std::make_pair(${target},Property::k${property_numerator}),[](const SimpleVariant& value){
              id(${property_numerator}).publish_state(static_cast<std::uint16_t>(value) + (id(${property_minor}).state));
            });
            // initial queueing of the Wh and kWh value
            queueRequest(${target}, Property::k${property_minor});
            queueRequest(${target}, Property::k${property_numerator});

  time:
    - platform: sntp
      on_time:
        # Every hour, every 5 minutes except midnight.
        - seconds: 0
          minutes: ${interval}
          hours: 0-23
          then:
            - lambda: |-
                queueRequest(${target}, Property::k${property_minor});
                queueRequest(${target}, Property::k${property_numerator});
        - seconds: 0
          minutes: 0
          hours: 1-23
          then:
            - lambda: |-
                queueRequest(${target}, Property::k${property_minor});
                queueRequest(${target}, Property::k${property_numerator});
        # At midnight reset power consumptions. And save offset for the next day.
        - seconds: 0
          minutes: 0
          hours: 0
          then:
            - lambda: |-
                // set the current Wh value as offset for the next day
                id(gOFFSET_${property_minor}) = id(${property_minor}).state;
                // reset the value at mightnight
            - sensor.template.publish:
                id: ${property_numerator}
                state: 0.0
